<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Blocking I/O · ZIO NIO</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="The default ZIO runtime assumes that threads will never block, and maintains a small fixed-size thread pool to perform all its operations. If threads become blocked, CPU utilization can be reduced as the number of available threads drops below the number of available CPU cores. If enough threads block, the entire program may halt."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Blocking I/O · ZIO NIO"/><meta property="og:type" content="website"/><meta property="og:url" content="https://zio.github.io/zio-nio/"/><meta property="og:description" content="The default ZIO runtime assumes that threads will never block, and maintains a small fixed-size thread pool to perform all its operations. If threads become blocked, CPU utilization can be reduced as the number of available threads drops below the number of available CPU cores. If enough threads block, the entire program may halt."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/zio-nio/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100,"cornerOffset":100}
          )
        });
        </script><script src="/zio-nio/js/scrollSpy.js"></script><link rel="stylesheet" href="/zio-nio/css/main.css"/><script src="/zio-nio/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zio-nio/"><img class="logo" src="/zio-nio/img/navbar_brand2x.png" alt="ZIO NIO"/><h2 class="headerTitleWithLogo">ZIO NIO</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/zio-nio/docs/essentials/essentials_index" target="_self">Essentials</a></li><li class=""><a href="/zio-nio/docs/usecases/usecases_index" target="_self">Use Cases</a></li><li class=""><a href="api" target="_self">API</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Essentials</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Essentials</h3><ul class=""><li class="navListItem"><a class="navItem" href="/zio-nio/docs/essentials/essentials_index">Overview</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/zio-nio/docs/essentials/essentials_blocking">Blocking I/O</a></li><li class="navListItem"><a class="navItem" href="/zio-nio/docs/essentials/essentials_files">File Channel</a></li><li class="navListItem"><a class="navItem" href="/zio-nio/docs/essentials/essentials_sockets">Socket Channel</a></li><li class="navListItem"><a class="navItem" href="/zio-nio/docs/essentials/essentials_resources">Resource Management</a></li><li class="navListItem"><a class="navItem" href="/zio-nio/docs/essentials/essentials_charsets">Character Sets</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Blocking I/O</h1></header><article><div><span><p>The default ZIO runtime assumes that threads will never block, and maintains a small fixed-size thread pool to perform all its operations. If threads become blocked, CPU utilization can be reduced as the number of available threads drops below the number of available CPU cores. If enough threads block, the entire program may halt.</p>
<p>Another issue with blocked threads is interruption. It is important that if the ZIO fiber is interrupted that this cancels the blocking operation and unblocks the thread.</p>
<p>Many NIO operations can block the calling thread when called. ZIO-NIO provides APIs to help ZIO-based code deal with this. The following describes how to use channels that offer blocking operations, which is all channels except for the asynchronous ones.</p>
<h2><a class="anchor" aria-hidden="true" id="blocking-and-non-blocking-channel-operations"></a><a href="#blocking-and-non-blocking-channel-operations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Blocking and Non-Blocking Channel Operations</h2>
<p>Channel APIs that may block are not exposed on the channel itself. They are accessed via the channel's <code>useBlocking</code> method. You provide this method a function that excepts a <code>BlockingOps</code> object and returns a <code>ZIO</code> effect value. The <code>BlockingOps</code> parameter will be appropriate to the type of channel and has the actual blocking I/O effects such as read and write.</p>
<p>The <code>useBlocking</code> method performs some setup required for safe use of blocking NIO APIs:</p>
<ul>
<li>Puts the channel in blocking mode</li>
<li>Runs the resulting effect value on ZIO's blocking thread pool, leaving the standard pool unblocked.</li>
<li>Installs interrupt handling, so the channel will be closed if the ZIO fiber is interrupted. This unblocks the blocked I/O operation. (Note that NIO does not offer a way to interrupt a blocked I/O operation on a channel that does not close the channel).</li>
</ul>
<p>Non-blocking usage does not require this special handling, but for consistency the non-blocking operations are accessed in a similar way by calling <code>useNonBlocking</code> on the channel. For some channels there are some small differences between the blocking and non-blocking APIs. For example, <code>SocketChannel</code> only offers the <code>finishConnect</code> operation in the non-blocking case, as it is never needed in blocking mode.</p>
<pre><code class="hljs css language-scala mdoc:silent"><span class="hljs-keyword">import</span> zio.<span class="hljs-type">ZIO</span>
<span class="hljs-keyword">import</span> zio.nio._
<span class="hljs-keyword">import</span> zio.nio.channels._

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readHeader</span></span>(c: <span class="hljs-type">SocketChannel</span>): <span class="hljs-type">ZIO</span>[<span class="hljs-type">Blocking</span>, <span class="hljs-type">IOException</span>, (<span class="hljs-type">Chunk</span>[<span class="hljs-type">Byte</span>], <span class="hljs-type">Chunk</span>[<span class="hljs-type">Byte</span>])] =
 c.useBlocking { ops =&gt;
   ops.readChunk(<span class="hljs-number">10</span>) &lt;*&gt; ops.readChunk(<span class="hljs-number">25</span>)
 }
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="using-managed-channels"></a><a href="#using-managed-channels" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using Managed Channels</h3>
<p>To help with the common use-case where you want to create a channel, there is versions of <code>useBlocking</code> and <code>useNonBlocking</code> that can be called directly on a managed value providing a channel.</p>
<p><code>useNioBlocking</code> provides both the channel and the requested type of operations:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.nio._
<span class="hljs-keyword">import</span> zio.nio.channels._

<span class="hljs-type">SocketChannel</span>.open.useNioBlocking { (channel, blockingOps) =&gt; 
  blockingOps.readChunk(<span class="hljs-number">100</span>) &lt;*&gt; channel.remoteAddress
}
</code></pre>
<p>If you don't need the channel, there's <code>useNioBlockingOps</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> zio.nio.channels._

<span class="hljs-type">SocketChannel</span>.open.useNioBlockingOps { blockingOps =&gt; 
  blockingOps.readChunk(<span class="hljs-number">100</span>)
}
</code></pre>
<p>To use the channel in non-blocking mode, there's corresponding <code>useNioNonBlocking</code> and <code>useNioNonBlockingOps</code> methods.</p>
<h3><a class="anchor" aria-hidden="true" id="avoiding-asynchronous-boundaries"></a><a href="#avoiding-asynchronous-boundaries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Avoiding Asynchronous Boundaries</h3>
<p>If you have a complex program that makes more than one call to <code>useBlocking</code>, then it may be worth running <em>all</em> of the ZIO-NIO parts using the blocking pool. This can be done by wrapping the effect value with your ZIO-NIO operations in <code>zio.blocking.blocking</code>.</p>
<p>If this isn't done, you can end up with the calls using <code>BlockingOps</code> running on a thread from the blocking pool, while the other parts run on a thread from the standard pool. This involves an &quot;asynchronous boundary&quot; whever the fiber changes the underlying thread it's running on, which imposes some overheads including a full memory barrier. By using <code>zio.blocking.blocking</code> up-front, all the code can run on the same thread from the blocking pool.</p>
<h2><a class="anchor" aria-hidden="true" id="comparing-the-channel-options"></a><a href="#comparing-the-channel-options" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comparing the Channel Options</h2>
<p>There are three main styles of channel available: blocking, non-blocking and asynchronous. Which to choose?</p>
<h3><a class="anchor" aria-hidden="true" id="blocking-channels"></a><a href="#blocking-channels" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Blocking Channels</h3>
<p>Easy to use, with a straight-forward operation. The downsides are that you have to use <code>useBlocking</code>, which creates a new thread, and will create an additional thread for every forked fiber subsequently created. Essentially you have a blocked thread for every active I/O call, which limits scalability. Also, the additional interrupt handling logic imposes a small overhead.</p>
<h3><a class="anchor" aria-hidden="true" id="non-blocking-channels"></a><a href="#non-blocking-channels" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Non-Blocking Channels</h3>
<p>These scale very well because you basically do as many concurrent I/O operations as you like without creating any new threads. The big downside is that they aren't of practical use without using a <code>Selector</code>, which is <em>very</em> tricky API to use correctly.</p>
<p>Note that while it is possible to use non-blocking channels without a <code>Selector</code>, this means you have to busy-wait on the channel for the simplest reads and writes. It's not efficient.</p>
<p>The other issue is that only network channels and pipes support non-blocking mode.</p>
<h3><a class="anchor" aria-hidden="true" id="asynchronous-channels"></a><a href="#asynchronous-channels" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Asynchronous Channels</h3>
<p>Asynchronous channels give us what we want: we don't need a <code>Selector</code> to use them, and our thread will never block when we use them.</p>
<p>However, it should be noted that asynchronous file I/O is not currently possible on the JVM. <code>AsynchronousFileChannel</code> is performing blocking I/O using a pool of blocked threads, which exactly what <code>useBlocking</code> does, and shares the same drawbacks. It may be preferable to use a standard <code>FileChannel</code>, as you'll have more visibility and control over what's going on.</p>
<p>The asynchronous socket channels do <em>appear</em> to use non-blocking I/O, although they also have some form of internal thread pool as well. These should scale roughly as well as non-blocking channels. One downside is that there is no asynchronous datagram channel.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/zio-nio/docs/essentials/essentials_index"><span class="arrow-prev">← </span><span>Overview</span></a><a class="docs-next button" href="/zio-nio/docs/essentials/essentials_files"><span>File Channel</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#blocking-and-non-blocking-channel-operations">Blocking and Non-Blocking Channel Operations</a><ul class="toc-headings"><li><a href="#using-managed-channels">Using Managed Channels</a></li><li><a href="#avoiding-asynchronous-boundaries">Avoiding Asynchronous Boundaries</a></li></ul></li><li><a href="#comparing-the-channel-options">Comparing the Channel Options</a><ul class="toc-headings"><li><a href="#blocking-channels">Blocking Channels</a></li><li><a href="#non-blocking-channels">Non-Blocking Channels</a></li><li><a href="#asynchronous-channels">Asynchronous Channels</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section><div><div class="gitter-open-chat-button">Open Chat</div><script type="text/javascript">
        ((window.gitter = {}).chat = {}).options = {
          showChatByDefault: false,
          activationElement: '.gitter-open-chat-button',
          room: 'zio/zio-nio'
        };
      </script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async="" defer=""></script></div></section><section class="sitemap"><a href="/zio-nio/" class="nav-home"><img src="/zio-nio/img/sidebar_brand2x.png" alt="ZIO NIO"/></a><div><h5>GitHub</h5><a class="github-button" href="https://github.com/zio/zio-nio" data-icon="octicon-star" data-count-href="/zio/zio-nio/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div><div><h5>Additional resources</h5><a href="/zio-nio/api">Scaladoc of ZIO</a></div></section><section class="copyright">Copyright © 2022 ZIO Maintainers</section></footer></div></body></html>